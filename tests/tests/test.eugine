import util
// // import ifc

// Log.info("begin")
// // let model = Ifc.read("C:/Users/coyove/Dropbox/ifc/main.ifc")
// // Log.info(len(model.objects))

// // // model.walk((obj) => 
// // //     if Ifc.isRelGroup(obj) {
// // //         println((let g = obj.get<RelatingGroup>).get<Name> + ":", typeof g.nativeObject)

// // //         for obj.get<RelatedObjects> do (robj, i) =>
// // //             println("  ", i, ": ", robj.get<Name>)
// // //     })

// // List.filter(model.objects, Ifc.isRelGroup && Ifc.its<RelatingGroup>.isSystem)
// def curry(a, b, c) => a + b + c

// let zzz  =curry(1)
// let zzz2  =zzz(2)
// println(zzz2(1))
// println(zzz2(2))
// println(zzz(10, 2))
// println(curry(2, 10)(3))

// def add(args...) => if len(args) == 2 args[0] + args[1] else {
//     let b = args[1..]
//     args[0] + add(b...)
// }

// println(add(1, 2))
// println(add(1, 2, 10))

// Meta.set(add, 0, @println(args))
// println(add(1, 2, 10, 90))

// def foo(a,b)=>println(a)
// foo(1, 2)

// Meta.get(foo, 0).arguments = [@b ]
// foo(1, 2)

// for Meta.body(Debug) do (expr) => 
//     if typeof(expr.varValue) == "core.PLambda" &&
//         typeof(expr.varValue.body[0]) == "library.SEPrint" {
//     Log.info(expr.varValue.body[0].arguments)
// }

// Log.info("end")

// def struct complex(r, i) => {
//     let this.real = r
//     let this.image = i

//     def operator add(left, right) => @ret(complex(left.real, left.image)) {
//         ret.real += right.real
//         ret.image += right.image
//     }

//     def operator tostring(this) => str(this.real) + "+" + this.image + "i"
// }

// let a = complex(0.0, 0.0)
// for 0..2000 do (i) => 
//     for 0..2000 do (j) => 
//         a += complex(i, j)

// Log.info(a)
// exit()

Debug.start()
// for 0..10000000 do () => {
// 	let a = 1
// 	let b = 1.0 / 4.5 + 2 / a * 4 - a
// }

// println(b)
// // Debug.assert(true == true && false == false && true != false &&
// //  !false && true && !null && 1 && !0 && " " && !"" && (true && false || true) &&
// //  1 == 1 && 1 < 2 && 1 <= 1 && 2 > 1 && 2 >= 1 && 2 == 2 &&
// //  -1 == -1 && 0 > -1 && -1 < 0 && -1 >= -2 && -2 <= -1 &&
// //  null == null && 1 != null && "a" == "a" && "abcdef" == "abcdef" &&
// //  "a" != "b" && "" != null && "" != 0 && "" != [] && 0 != [] &&
// //  __integer_max__ == __integer_max__ && __integer_min__ == __integer_min__, "Basic Comparisons")

// // Debug.assert(1 + 1 == 2 && 1 - 3 == -2 && 1 + 2 -3 + 4 == 4 &&
// //  1 + 2 * 3 == 7 && 1 + 0.1 == 1 && 0.1 - 1 == -0.9 && 1.0e6 * 10 == 1.0e7 &&
// //  10 * 0.2 == 0 && 10.0 * 0.2 - 2 < 1.0e-6 && (1 +2)/3==1 && 7 % 2 == 1 &&
// //  10.1 % 3 - 1.1 < 1.0e-6 && null + 1 == null, "Elementary Arithmetic Operations")

// // Debug.assert(Utils.deepCompareList([1,3,[1,2]], [1,3,[1,2]]) &&
// //  Utils.deepCompareList([1,2, 3], [1,2,3]) && 
// //  !Utils.deepCompareList([1,2,4,5,6], [1,3,7,8]), "List Deep Comparisons")

// // def fibonacci (n) =>
// //  if n < 2 {1} else fibonacci(n - 1) + fibonacci(n - 2)
// // Debug.assert(Utils.deepCompareList(map(fibonacci, range(0,1,10)), [1, 1, 2, 3, 5, 8, 13, 21, 34, 55]), "Fibonacci")

// // def numSeqSum (n, sum) =>
// //  if n == 0 {sum} else numSeqSum(n -1,sum+n)
// // Debug.assert(numSeqSum(10000, 0) == 50005000, "Sum of Number Sequence 1 ~ 10000")


let N = 1600
let Crb = range(N + 7, 0, 0.0), Cib = range(N + 7, 0, 0.0)
let invN = 2.0/N
for 0..N do (i) => { 
	Cib[i] = invN * i - 1.0
	Crb[i] = invN * i - 1.5
} 

let yCt = 0
def incr() => sync yCt++

let linelen = (N + 7) / 8
let out = range(N * linelen, 0, 0.0)

def putLine(y) =>
	for 0..linelen do (xb) => {
		let x = xb * 8
		let res = 0
        for [0, 2, 4, 6] do (i) => {
            let Ciby = Cib[y]
            let Crbx = Crb[x+i]
            let Crbx1 = Crb[x+i+1]

            let Zr1 = Crbx, Zr2 = Crbx1
            let Zi1 = Ciby, Zi2 = Ciby

            let b = 0
            let j = 50

            enter for j-- > 0 do () => {
                let nZr1=Zr1*Zr1-Zi1*Zi1+Crbx
                let nZi1=Zr1*Zi1*2+Ciby
                Zr1=nZr1
                Zi1=nZi1

                let nZr2=Zr2*Zr2-Zi2*Zi2+Crbx1
                let nZi2=Zr2*Zi2*2+Ciby
                Zr2=nZr2
                Zi2=nZi2

                if Zr1*Zr1+Zi1*Zi1>4 { 
                	b = Bit.or(b, 2)
                	if b==3 exit(1)
                }
                if Zr2*Zr2+Zi2*Zi2>4 { 
                	b = Bit.or(b, 1)
                	if b==3 exit(1)
                }
            }

            res = res * 4 + b

        }
        out[y * linelen + xb] = res
	}

def worker () => {
	let y = 0
	for (y = incr()) < N do () => System.dup(putLine)(y)
}

let threads = []
for 0..4 do () =>
	threads <+ System.dup(worker)#()

for threads do (t) => wait(t)

Pbm.write("test.pbm", N, N, out)

Debug.summary()