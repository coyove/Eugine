import util
sleep(5000)
Debug.start()
// Debug.assert(true == true && false == false && true != false &&
//  !false && true && !null && 1 && !0 && " " && !"" && (true && false || true) &&
//  1 == 1 && 1 < 2 && 1 <= 1 && 2 > 1 && 2 >= 1 && 2 == 2 &&
//  -1 == -1 && 0 > -1 && -1 < 0 && -1 >= -2 && -2 <= -1 &&
//  null == null && 1 != null && "a" == "a" && "abcdef" == "abcdef" &&
//  "a" != "b" && "" != null && "" != 0 && "" != [] && 0 != [] &&
//  __integer_max__ == __integer_max__ && __integer_min__ == __integer_min__, "Basic Comparisons")

// Debug.assert(1 + 1 == 2 && 1 - 3 == -2 && 1 + 2 -3 + 4 == 4 &&
//  1 + 2 * 3 == 7 && 1 + 0.1 == 1 && 0.1 - 1 == -0.9 && 1.0e6 * 10 == 1.0e7 &&
//  10 * 0.2 == 0 && 10.0 * 0.2 - 2 < 1.0e-6 && (1 +2)/3==1 && 7 % 2 == 1 &&
//  10.1 % 3 - 1.1 < 1.0e-6 && null + 1 == null, "Elementary Arithmetic Operations")

// Debug.assert(Utils.deepCompareList([1,3,[1,2]], [1,3,[1,2]]) &&
//  Utils.deepCompareList([1,2, 3], [1,2,3]) && 
//  !Utils.deepCompareList([1,2,4,5,6], [1,3,7,8]), "List Deep Comparisons")

// def fibonacci (n) =>
//  if n < 2 {1} else fibonacci(n - 1) + fibonacci(n - 2)
// Debug.assert(Utils.deepCompareList(map(fibonacci, range(0,1,10)), [1, 1, 2, 3, 5, 8, 13, 21, 34, 55]), "Fibonacci")

// def numSeqSum (n, sum) =>
//  if n == 0 {sum} else numSeqSum(n -1,sum+n)
// Debug.assert(numSeqSum(10000, 0) == 50005000, "Sum of Number Sequence 1 ~ 10000")
var N = 160
var Crb = range(N + 7, 0, 0.0), Cib = range(N + 7, 0, 0.0)
var invN = 2.0/N
for 0..N do (i) => { 
	Cib[i] = invN * i - 1.0
	Crb[i] = invN * i - 1.5
}

var yCt = 0
def incr() => sync yCt++

var linelen = (N + 7) / 8
var out = range(N * linelen, 0, 0.0)

def putLine(y) =>
	for 0..linelen do (xb) => {
		var x = xb * 8
		var res = 0
        for [0, 2, 4, 6] do (i) => {
            var Zr1 = Crb[x+i]
            var Zi1 = Cib[y]
            var Zr2 = Crb[x+i+1]
            var Zi2 = Cib[y]

            var b = 0
            var j = 50

            enter for j-- > 0 do () => {
                var nZr1=Zr1*Zr1-Zi1*Zi1+Crb[x+i]
                var nZi1=Zr1*Zi1+Zr1*Zi1+Cib[y]
                Zr1=nZr1
                Zi1=nZi1

                var nZr2=Zr2*Zr2-Zi2*Zi2+Crb[x+i+1]
                var nZi2=Zr2*Zi2+Zr2*Zi2+Cib[y]
                Zr2=nZr2
                Zi2=nZi2

                if Zr1*Zr1+Zi1*Zi1>4 { 
                	b = Bit.or(b, 2)
                	if b==3 exit(1)
                }
                if Zr2*Zr2+Zi2*Zi2>4 { 
                	b = Bit.or(b, 1)
                	if b==3 exit(1)
                }
            }

            res = res * 4 + b
        }
        out[y * linelen + xb] = res
	}

def worker () => {
	var y = 0
	for (y = incr()) < N do () => putLine(y)
}

var threads = []
for 0..2 do () =>
	threads <+ worker#()

for threads do (t) => wait(t)

Pbm.write("test.pbm", N, N, out)

Debug.summary()
