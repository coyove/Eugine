import Cookie

(def Util() => {
    var javaURLDecoder = static java/net/URLDecoder
    var javaURLEncoder = static java/net/URLEncoder
    var thisUtil = this

    def this.struct1 (f, args...) => {       
        f(args...)
        clone f
    }     

    def this.encodeURI (text) => 
        javaURLEncoder::encode(text : String, "utf-8" : String)

    def this.decodeURI (text) => 
        javaURLDecoder::decode(text : String, "utf-8" : String)

    def this.filterString (text) => 
        encodeURI((static org/apache/commons/lang3/StringEscapeUtils)::escapeHtml3(text))

    def this.filterName (name) => {
        name = (static org/apache/commons/lang3/StringEscapeUtils)::escapeHtml3(String.replace(name, "!", "_"))

        if contains(name, "#") > -1 {
            var names = String.split(name, "#")

            if Config.mods[names[0]] == names[1] {
                name = "<span mod>" + names[0] + "</span>"
            } else {
                name = names[0] + "<span tripcode>!" + Util.hashString2(names[1])[0..4] + "</span>"
            }
        }

        encodeURI(name)
    }

    def this.filterComment (text) => @ret("") {
        text = (static org/apache/commons/lang3/StringEscapeUtils)::escapeHtml3(text)

        var lines = String.split(text, "\n")
        var codeFlag = false
        def replacer (t) => {
            t = String.regexReplace(t, @"(https?:\/\/\S+)", "<a class='link' href='$1' target='_blank'>$1</a>")
            t = String.regexReplace(t, @"&gt;&gt;No\.(\d+)",
"<a class='aref' onmouseover='openref($1, this)' onmouseout='closeref($1, this)' href='javascript:open($1)'>&gt;&gt;No.$1</a>")
            String.regexReplace(t, @"^&gt;(.+)", "<span quote>&gt;$1</span>")
        }

        var tooManyLines = false
        for lines do (line, i) => {

            if String.trim(line) == "```" { 
                codeFlag = !codeFlag

                if codeFlag
                    ret <+ "<pre><code>"
                else
                    ret <+ "</pre></code>"
            } else if codeFlag {
                if i >= Config.tooManyLines && !tooManyLines {
                    tooManyLines = true
                    ret <+ "</pre></code><div class='tml'><pre><code>"
                }
                ret <+ line <+ "\n"
            } else {
                if i >= Config.tooManyLines && !tooManyLines {
                    tooManyLines = true
                    ret <+ "<div class='tml'>"
                }
                ret <+ "<span>" <+ replacer(line) <+ "</span><br>"
            }
        }

        if tooManyLines {
            ret <+ "</div>"
        }

        ret = encodeURI(ret)
    }

    def this.makeDir (path) => {
        var p = (static java/nio/file/Paths)::get(path, []: java/lang/String...)
        
        if !File.exists(path) {
            (static java/nio/file/Files):>createDirectories(p: java/nio/file/Path, 
                []: java/nio/file/attribute/FileAttribute...)
        }

        path
    }

    def this.makeFile (path, initData) => {
        if !File.exists(path) File.write(path, initData)
        path
    }

    def this.startsWith (text, prefix) =>
        if len(text) < len(prefix)
            false
        else 
            text[0..len(prefix)] == prefix

    def this.endsWith (text, suffix) =>
        if (var tl = len(text)) < (var sl = len(suffix))
            false
        else 
            text[(tl-sl)..tl] == suffix

    def this.randomString(length) => {
        var table = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"
        var ret = ""
        for 0..length do () => 
            ret += table[Math.floor(Math.random(0) * 58)]

        ret
    }

    def this.hashString(text) =>
        Digest.hexSHA1(Digest.SHA256(text + Config.salt))

    def this.hashString2(text) =>
        Digest.hexSHA1(Digest.SHA256(Digest.SHA256(text + Config.salt)))

    def this.isEndOfStream (stream) => {
        var length = len(stream);

        (stream[length - 1] == "\n" && stream[length - 3] == "\n") &&
        (stream[length - 2] == "\r" && stream[length - 4] == "\r")
    }

    def this.getRss (url) => {
        var now = Time.unix(1)
        var ret = ""
        
        enter if contains(rssCache, url) && (now - rssCache[url].updated < 2000) {
            println("cache hit: ", url)
            ret = rssCache[url].rss
        } else {
            var obj = new java/net/URL(url : String)
            var conn = obj::openConnection()

            // error when url is invalid
            var br = new java/io/BufferedReader(
                new java/io/InputStreamReader(conn:>getInputStream(): java/io/InputStream): java/io/Reader)

            var inputLine = "", response = new java/lang/StringBuffer()

            for (inputLine = br::readLine()) != null do () =>
                response:>append(inputLine : String)

            br:>close()
            var rss = response::toString()

            rssCache[url] = { updated: Time.unix(1), rss : rss }
            ret = rss
        } do ret
    }

    def this.trimIP(ip) => {
        if contains(ip, ":") > -1 {
            var parts = String.split(ip, ":") // buggy, abbreviation is not considered
            String.join(parts[0..len(parts)/2], ".")
        } else {
            var parts = String.splitRaw(ip, ".")
            String.join(List.initOf(parts), ".")
        }
    }

    def this.rebuildPage(page, title, source) => enter {
        var threads = []

        if page == 1 {
            var sticky = File.readLines(stickyPath)
            for sticky do (id) => {
                var path = dataPath + int(id) / 1000 + "/" + id

                if File.exists(path) {
                    var thread = ThreadInTimeline(File.readLines(path))
                    thread.main.isSticky = true
                    threads <+ thread
                }
            }
        }

        var timeline = File.readLines(source)
        
        if len(timeline) > 500 {
            timeline = timeline[0..500]
            File.write(source, timeline)
        }

        var total = len(timeline)
        var start = (page - 1) * Config.threadsPerPage
        var end = page * Config.threadsPerPage
        var html = ""

        if total <= start exit(0)
        if total < end end = total

        for start..end do (i) => {
            var id = int(timeline[i])
            var path = dataPath + id / 1000 + "/" + id

            if File.exists(path) {
                var data = File.readLines(path)
                // var tit = 
                threads <+ ThreadInTimeline(data)
            }
        }
    } catch(e) {

    } do {
        Template.renderTimeline(page, title, threads)
    }

    def this.deleteAllCache() => {
        for 1..21 do (i) => {
            File.delete(dataPath + i + ".html")
            File.delete(dataPath + i + ".report.html")
        }
    }
})()