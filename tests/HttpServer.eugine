def [Util.struct] HttpServer(addr, port, timeout) => {
    var listenAddress = addr
    var listenPort = port
    var readTimeout = timeout

    var routerGET = {}
    var routerPOST = {}
    var router404 = null

    var this.mimeMapper = {
        "image/jpeg" : ".jpg",
        "image/jpg"  : ".jpg",
        "image/pjpeg": ".jpg",
        "image/png"  : ".png",
        "image/gif"  : ".gif",
        "image/x-png": ".png",
        "application/octet-stream": ".jpg",
    }

    def [Util.struct] this.HttpContext (socket) => {
        var responseSocket = socket
        var responseStream = socket::getOutputStream()

        var this.headers = {}

        def this.parseMultiPartBody() => {
            var this.postParams = {}
            var parts = parsePairs(this.headers["content-type"], ";")
            var boundary = "--" + parts.boundary

            var curBoundaryPos = 0
            enter for true do () => {
                var nextBoundary = contains(this.rawData, boundary, curBoundaryPos)
                if nextBoundary == -1 exit(0)

                var pos = curBoundaryPos + len(boundary) + 2 // 2 = \r\n
                var bod = contains(this.rawData, "\r\n\r\n", pos)
                if bod == -1 exit(0)

                var lines = String.splitRaw(chr(this.rawData[pos..bod]), "\r\n")
                var tmp = parsePairs(lines[0], ";")
                var key = tmp.name[1..len(tmp.name)-1]

                bod += 4
                var eod = contains(this.rawData, "\r\n" + boundary, pos)
                if eod == -1 exit(0)
                
                lines = List.tailOf(lines)

                if lines != null for lines do (line) => {
                    if Util.startsWith(line, "Content-Type") {
                        var ctype = String.trim(line[13..])::toLowerCase()
                        Log.info(ctype)
                        if contains(mimeMapper, ctype) {
                            this.postParams[key] = {
                                type: ctype,
                                values: tmp,
                                payload: this.rawData[bod..eod],
                            }
                        }
                    }
                }

                if !contains(this.postParams, key)
                    this.postParams[key] = Util.decodeURI(new java/lang/String(this.rawData[bod..eod]: byte[]))
                
                curBoundaryPos = eod
            } catch(e) {
                //     Log.warn(e)
            }
        }

        def this.parsePostBody () => {
            var this.postParams = parsePairs(this.data, "&")
            if this.route != null {
                var parts = String.split(this.route, "\\?")

                if len(parts) == 2 {
                    var tmp = parsePairs(parts[1], "&")
                    for tmp do (k) => 
                        this.postParams[k] = tmp[k]

                    this.route = parts[0]
                }
            }
        }

        def this.parseCookies () =>
            var this.cookies = parsePairs(if (this.rawCookie) this.rawCookie else "", ";")

        def parsePairs (text, delim) => {
            var pairs = String.split(text, delim)
            var ret = {}
            for pairs do (pair) => {
                var kv = String.split(pair, "=")
                var key = String.trim(kv[0])
                if len(kv) == 2 {
                    ret[key] = Util.decodeURI(String.trim(kv[1]))
                } else if len(kv) == 1 && key != "" {
                    ret[key] = ""
                }
            }

            ret
        }

        def this.writeCommon(status, ctype) => {
            switch status do {
                404 => this.write("HTTP/1.1 404 Not Found\r\n")
                403 => this.write("HTTP/1.1 403 Forbidden\r\n")
                400 => this.write("HTTP/1.1 400 Bad Request\r\n")
                302 => this.write("HTTP/1.1 302 Found\r\n")
                301 => this.write("HTTP/1.1 301 Moved Permanently\r\n")
                _   => this.write("HTTP/1.1 200 OK\r\n")
            }

            switch ctype do {
                "css"   => this.writeHeader("Content-Type", "text/css; charset=utf-8")
                "js"    => this.writeHeader("Content-Type", "application/x-javascript; charset=utf-8")
                "plain" => this.writeHeader("Content-Type", "text/plain; charset=utf-8")
                "html"  => this.writeHeader("Content-Type", "text/html; charset=utf-8")
                "xml"   => this.writeHeader("Content-Type", "text/xml; charset=utf-8")
                "png"   => this.writeHeader("Content-Type", "image/png")
                "jpg"   => this.writeHeader("Content-Type", "image/jpg")
                _       => this.writeHeader("Content-Type", "application/octet-stream")
            }
        }

        def this.writeCookie(key, value, options) => {
            var payload = key + "=" + value

            for options do (k, v) =>
                switch k do {
                    "Expires" => {
                        payload += "; Expires=" + Time.utcFormat(Time.unix(0) + v * 1000)
                        payload += "; Max-Age=" + v
                    }
                    "HttpOnly" => {
                        payload += "; HttpOnly"
                    }
                    _ => {
                        payload += "; " + k + "=" + v
                    }
                }
                // Log.info(str(buffer(payload)))
            this.writeHeader("Set-Cookie", payload)
        }

        def this.writeHeader (key, value) =>
            this.writeBytes(buffer(key + ": " + value + "\r\n"))

        def this.write(text...) => {
            var tmp = ""
            for text do (t) => tmp <+ t
            this.writeBytes(buffer(tmp))
        }

        def this.notFound() => {
            if router404 == null {
                this.writeCommon(404, "plain")
                this.eoh()
            } else {
                router404(this)
            }
        }

        def this.redirect302(location) => {
            this.writeCommon(302, "html")
            this.writeHeader("Location", location)
            this.eoh()
        }

        def this.serveFile(path) => {
            path = String.replace(path, "..", "")

            if File.exists(path) {
                var _ = Util.endsWith(path)
                switch true do {
                    _(".html") => this.writeCommon(200, "html")
                    _(".js")   => this.writeCommon(200, "js")
                    _(".png")  => this.writeCommon(200, "png")
                    _(".css")  => this.writeCommon(200, "css")
                    _(".jpg")  => this.writeCommon(200, "jpg")
                    _          => this.writeCommon(200, "")
                }
                this.eoh()

                if _(".raw.html") {
                    this.write(Template.header(""))
                    this.write(File.read(path))
                    this.write(Template.footer())
                } else {
                    this.writeBytes(File.readBinary(path))
                }
            } else 
                this.notFound()
        }

        def this.eoh() =>
            this.writeBytes(buffer("\r\n"))

        def this.writeBytes(bytes) =>
            if !responseSocket::isClosed()
                responseStream:>write(bytes : byte[])

        def this.close() => {
            responseStream:>close()
            responseSocket:>close()
        }
    }

    def handle (client) => {
        client::setSoTimeout(readTimeout)
        var is = client::getInputStream()
        var context = _HttpServer.HttpContext(client)

        enter {
        var buf    = buffer(1024 * 128), 
            rawBuf = buffer(0),
            read   = 0

        var totalRead    = 0,
            bodyLength   = 0,
            headerLength = 0,
            totalLength  = 0

        enter for read != -1 do () => {
            totalRead += (read = is::read(buf : byte[]))
            rawBuf <+ buf[0..read]
            // rawRequest <+ chr(buf)

            if !bodyLength {
                var m = String.match(chr(rawBuf), @"(?i)content-length:\s?(\d+)")
                if len(m) > 0
                    bodyLength = num(String.split(m[0].text, ":")[1]) // we found Content-Length header
            }

            if !headerLength {
                m = String.match(chr(rawBuf), @"(\r\n\r\n)")
                if len(m) > 0
                    totalLength = (headerLength = m[0].end) + bodyLength // we reach the end of HTTP request headers
            }

            totalLength != totalRead // || Util.isEndOfStream(rawRequest))
        } catch (e)
            Log.warn("Timeout:", e)

        // var requests = String.split(rawRequest[0..headerLength], "\r\n")
        var requests = rawBuf[0..headerLength]
        // for requests do (request) => {
        var eol = 0
        for true do () => {
            var nextEOL = contains(requests, "\r\n", eol)

            if nextEOL == -1 {
                false
            } else {
                var request = chr(requests[eol..nextEOL])
                var parts = String.split(request, " ")
                eol = nextEOL + 2

                var p = null
                if len(parts) > 1
                    switch p = parts[0]::toLowerCase() do {
                        "get" =>
                            var context.route = parts[1], context.method = "get"

                        "post" =>
                            var context.route = parts[1], context.method = "post"   

                        "cookie:" =>
                            var context.rawCookie = request[7..]

                        _ => {
                            var key = String.replace(p, ":", "")
                            if !contains(context.headers, key)
                                context.headers[key] = String.trim(request[len(parts[0])..])
                        }
                    }
            }
        }

        if context.method == null
            exit("invalid request (" + chr(rawBuf) + ")")

        // var context.data = rawRequest[headerLength..]
        var context.rawData = rawBuf[headerLength..]
        if context.method == "post" {
            var ctype = context.headers["content-type"]
            if ctype == "application/x-www-form-urlencoded" {
                context.parsePostBody()
            } else if ctype && contains(ctype, "multipart/form-data") > -1 {
                context.parseMultiPartBody()
            } else {
                exit(0)
            }
        }

        context.parseCookies()

        var context.ip = context.headers["x-forwarded-for"]
        if !context.ip
            context.ip = "un:kn:ow:n"

        switch context.method do {
            "get" => var rref = routerGET
            "post" => var rref = routerPOST
            _ => exit(1)
        }

        // if context.method == "post" && false { // context.headers["content-type"] != "" {
        //     context.writeCommon(403, "plain")
        //     context.write("\r\n")
        // } else {
        var found = false
        var tester = context.route
        if contains(rref, "_" + tester) {
            rref["_" + tester](context)
            found = true
        } else {
            for rref do (route, router) => {
                if Util.startsWith(tester, route) {
                    found = true
                    router(context)
                    false
                }
            }
        }

        if !found {
            if router404 == null {
                context.writeCommon(404, "plain")
                context.write("\r\n")
            } else {
                router404(context)
            }
        }
        // }

        // end of enter
        } catch(e) {
            Log.error(__e__, e)
        } do {
            is:>close()
            context.close()
        }
    }

    def this.addRouter(method, route, router) => {
        switch method::toLowerCase() do {
            "get" => routerGET[route] = router
            "post" => routerPOST[route] = router
            "404" => router404 = router
        }
    }

    def this.start() => {
        var ss = new java/net/ServerSocket()
        ss:>bind(new java/net/InetSocketAddress(listenAddress, listenPort): java/net/SocketAddress)

        for true do () => {
            var client = ss::accept()
            handle#(client)

            /* DO NOT write "handle#(ss::accept())" because it
               will continously create new thread without being blocked and cause GC overhead eventually
            */
        }
    }

    var _HttpServer = this
}